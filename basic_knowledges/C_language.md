# C语言进阶
[toc]
## C专家编程
[C专家编程+清晰+（有书签索引）.pdf](../../../books/C语言/C专家编程+清晰+（有书签索引）.pdf)
看书时间：11月27日-12月10日（13天，24.5h） 
预览：C语言的发展历史；语言特性问题及缺陷；声明，分解声明；typedef的用法及typedef与struct连用；指针和数组能不能混用的情况；介绍了动态链接和静态链接，以及interposing问题；可执行二进制代码的段结构，程序运行，堆栈情况，使用setjmp/longjmp用于错误恢复，C语言工具；关于内存，虚拟内存；类型提升，函数原型，C语言实现有限状态机（函数指针），Hash表，强制类型转换；数组和指针可以互换的情况，多维数组；多维数组的内存发布，指针数组；C++的特性；
### 第一章
* “小启发”：实际工作的一些想法、经验和指导方针
* C语言起源于1969年一个失败了操作系统项目Multics
* C语言的特性与硬件十分相关，并且方便编译器设计者
  * 数组下标从0开始——偏移量概念
  * 基本数据类型——与硬件相关，底层硬件支持不同数据类型
  * auto 自动内存分配，变量默认分配模式——方便编译器设计者
  * 表达式中的数组名看做指针——简化编译器
  * 不允许嵌套函数（函数内部包含另一函数定义）——简化编译器
  * register 关键字，把变量分配到寄存器中——方便编译器
* C语言中，大多数库函数和辅助程序需要显式调用——而C++不是（C++改造函数和析构函数自动调用）
* 预处理器实现三个主要功能：
  * 字符串替换：可为常量提供一个符号名
  * 头文件包含：一般性说明被分离到头文件中，可以被多个源文件使用
  * 通用代码模板拓展：与函数不同，宏在连续几个调用中所接收的参数的类型可以不同
  * ！！！宏拓展中，空格会影响拓展结果！！！
    ```
    #define a(y) a_expanded(y)
    与
    #define a (y) a_expanded (y)
    后者被拓展为
    a(x) : (y) a_expanded (y)(x)
    ```
  * ! 在宏里使用花括号也不会把多条语句组合成一条复合语句，建议适量使用，在C++有新方法可以替代预处理器？？
  * 不要用C语言的预处理器修改语法结构，因为难以维护
    * 宏最好只用来变量命名或简记一些适当结构
    * ！宏名应该大写与函数调用分开
* 复合赋值符引入了一个麻烦：任何东西跟在赋值符的后面都会被换序，而且不会报错，所以赋值符后勤加空格
* ANSI C标准术语：不可移植的代码（未确定的），坏代码（未定义的，约束条件）；可移植的代码（遵循标准，保证无论在说明平台都能输出相同的输出，依赖编译器）
  * 保证可移植性，应该始终加上必要的类型转换、返回值等
  * 不遵循标准，但不是约束条件，编译器不会给警告......
* 标准规定编译器只**在违反语法规则和约束条件的情况下**才出错误信息
  * 未定义的（不对但标准没规定怎么做），比如标准规定C语言说明的标识符均保留，所以不能声明malloc(),但这不是约束条件，违反它编译器不会警告，导致interpositioning问题
* ANSI C标准的结构：术语，环境，标准，库；附录F：一般警告消息，附录G：可移植性话题（集中建议）
* 标准不是必然完整一致正确的：标准设立后不轻易改动，即使修改错误
* K＆R C 与 ANSI C的区别：
  * 1. 新的、不同的、重要的东西——**原型**
    * `char * strcpy(char *dst, const char *src);`最好不要省略形参名
  * 2. 新关键字
  * 3. 安静的改变——相邻字符串字面值会自动连接
  * 4. 除上述三者之外，包括争议内容
* P19（分析，不能理解） 实参和形参不相容问题（`char* s`和`const char *p`看似相容，而`char **argv`和`const char **p`不相容）
* const 关键字的作用是限定函数的形参，该函数就不会修改实参指针数据（相反赋值会出错）；const 和 * 的组合通常只在数组形式的参数中模拟传值调用
* 安静的改变——“寻常算数转换”：
  * ACSI C——（值保留）算数运算时，操作数类型不同，就会转换，转换到不丢失信息
  * K＆R C——无符号保留，操作数有无符号数，结果就会转换为无符号
  * `if(d <= TOTAL_ELEMENTS - 2)` TOTAL_ELEMENTS为unsigned int，d会被转换为unsigned int，若 d = -1，那会被转换为一个很大的正数导致if一直为假！！！修正这个问题加强制类型转换
  * 建议：
    * 少使用无符号类型，尽量使用有符号类型
    * 使用位段和二进制掩码时，才用无符号数
* 代码风格：
  * `#define TOTAL_ELEMENTS (sizeof(array) / sizeof(array[0]))` 在不修改define的前提下，可修改数据类型，这段代码更通用
  * sizeof的返回值是无符号整型
* #pragma 用来向编译器提供信息

### 第二章
* malloc(strlen(str)+1),考虑字符串结尾的`\0`
* 多做之过，少做之过，误做之过
* NUL结束字符串，NULL表示空指针
#### 多做之过
* switch：fall through
  * default位置任意，可有可没有（效果不一样）
  * 257case（256可能值+EOF）
  * 问题：
    * 对case可能出现的值过于放纵？可以在花括号后做一些说明，但语句只从case处执行
    * 内部任何语句都可以被加上标签，执行时会跳转：打错字不提醒
    * （fall through）不会在匹配的case标签后语句执行完毕后自动中止，除非遇到break
      * case与if嵌套，if中使用break也会跳出Switch循环，导致某些语句未执行
* 相邻字符串常量合并，省略行末加“\”
  * 字符串数值赋值时，漏掉逗号，编译器会直接合并字符串，没有错误信息
  * 小启发：第一次执行和以后执行时行为不同
    * 通过说明静态变量，初始为空格以后为逗号
    ```c
    generate_initializer(char * string) {
        static char separator = ' ';
        printf("%c %s \n",separator,string);
        separetor = ',';
    }
    ```
  * 拖尾逗号在其他情况，比如枚举说明，单行多变量说明中不允许使用
* C函数默认是全局可见的（extern），限制在这个文件之外不见，在前面加static
  * 会产生interpositioning问题
  * 可见性选择有限
  * 一个大型函数的内部函数不得不在函数外定义，但不加static，他们都是全局可见的，这不合理
#### 误做之过
* 许多符号被重载了（P37）：意思模糊和优先级问题
  * sizeof操作数是类型名，两边必须加括号，操作数是变量，则不必加括号
    * p = N * sizeof * q
  * 含义模糊apple = sizeof(int) * p [程序](../code/separator.c)
  * 符号优先级会造成问题（P38-P39）
    * . and [] and () `>` * ; == and != `>` & and | and << and >>
    *   == and != `>` = ;算数高于移位；逗号最低
*   表达式有bool，算数，位操作的混合运算，应该加括号
*   同优先级右结合性
*   标准库不安全语意：gets()
    * gets()把超过缓冲区的字符继续写入堆栈，覆盖了原先内容，可以修改堆栈中的过程活动记录，改变函数返回地址
      * > ？？？（堆栈的结构是什么样的，继续写入堆栈会怎么样？
#### 少做之过
* 参数的解析：区分选项开关和文件名——p44 shell参数解析
* 多空格问题：\newline and \ newline, 转移newline用于多行宏定义和字符串连续
* 不要空格问题：编译器理解错误 +++ 是 + ++ 还是++ +，*x/*y无空格/*会编译成注释内容，C++新注释 //也可能改变C代码含义
* 不要忘记结束注释
* P48 函数返回值是该函数内定义的局部变量会出现问题：函数结束，变量销毁，没人知道指针指向哪里
  * 返回一个指向字符串常量的指针
  * 使用全局声明的数组；缺点在于任何人都有可能修改该数组，且下次调用会覆盖数组内容
  * 使用静态数组；缺点下次调用也会被覆盖
    * 防止修改，拥有该数组指针的函数才能修改其内容
  * 显式分配一些内存，保存返回值；缺点需要承担内存管理
    * 每次调用创建新的缓冲区，不会覆盖以前的返回值
    * 同一代码块进行“malloc”和“free”操作，内存管理最轻松
  * > 为什么不能下次调用覆盖数组？
### 第三章
### C语言的缺陷

### C语言的声明
### 指针与数组
### 链接
### 程序运行与内存
### 其他细节
### C++